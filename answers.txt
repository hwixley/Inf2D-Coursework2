PART 1

Task 1.1

PREDICATES:
Road(A, B)        -- A and B are connected by a road 
		  **Road(A, B) implies Road(B, A) (roads are bidirectional routes)
Air(A, B)         -- A and B are connected by a directed air route A=>B
Agent.At(A)       -- The agent is at A
Car.At(A)	  -- The car is at A
Agent.Visited(A)  -- The agent has visited A

INITIAL STATE:
Agent.At(E) ∧ Car.At(E) ∧ ¬Agent.Visited(D)

GOAL STATE:
Agent.At(E) ∧ Agent.Visited(D)


Task 1.2

Drive(A, B) 	-- Drive from A to B
PRECON: Agent.At(A) ∧ Car.At(A) ∧ Road(A, B)
EFFECT: ¬Agent.At(A) ∧ ¬Car.At(A) ∧ Agent.At(B) ∧ Car.At(B)

Fly(A, B) 	-- Fly from A to B
PRECON: Agent.At(A) ∧ Air(A, B)
EFFECT: ¬Agent.At(A) ∧ Agent.At(B)

Visit(A) 	-- Visit A
PRECON: Agent.At(A) ∧ ¬Agent.Visited(A)
EFFECT: Agent.Visited(A)


Task 1.3

BACKWARD STATE SPACE SEARCH
Algorithm which starts at the goal state and ends at the initial state.

BACKWARDS STEPS
Initial state = agent at B, car at A, agent has visited B
Goal state = car and agent at E, and agent has not visited B

0: ¬Visit(B)	-- Action which completes part of the goal state
1: Fly(B, A)	-- Action which brings our agent closer to the goal state
2: Drive(A, E) 	-- Action which brings our agent to the complete goal state

Upon finding a path in a backwards state space search, the path must be reversed
and negated where appropriate.
	eg. Drive(A,B) -> Drive(B,A)  and  ¬Visit(B) -> Visit(B)
	**Parameters reversed for dynamic actions, state negated for static actions.

So the solution is:
0: Drive(E, A)
1: Fly(A, B)
2: Visit(B)


PART 4

CREATING AN EFFECTIVE PLANNER WHICH ACCOUNTS FOR A TRAVELLER'S PREFERENCES:

First we must identify possible preferences we can cater for;
1) Monetary cost (cost heuristic)
2) Length of the journey (distance heuristic)
3) Ease/comfort of the journey (number of transport changes)
4) Environmental factor (emission heuristic)

All of these preferences will have to be interpreted as their own metric values
within the planner in order for the program to be able to compare different 
route costs, and find the optimal preferred path.

Now we must create a way in which the traveller can prioritize their preferences.
This could be done by either allowing a customer to choose a single preference
or rather using all preferences ordered by importance.

Depending on which way the traveller prioritizes their preferences affects how
the final search metric is evaluated.

Single preference (A):
The final search metric is equated to preference A's metric value as this is all 
the system needs to account for and optimise in the search.
final-search-metric = metric_A

All preferences ordered by importance (A B C D):
Given we have to optimise the search on 4 different preferences with different
values of importance, we must create an equation which adds appropriate 
weightings to represent this prioritization:
final-search-metric = 4*metric_A + 3*metric_B + 2*metric_C + metric_D

Finally, given we have succesffully implemented the various preference metrics
within the domain, all we have to do is add the final search metric into the
:metric section of the problem definition.

  (:metric minimize (final-search-metric))
